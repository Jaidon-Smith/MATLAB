<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="generator" content="MATLAB R2018a"><meta http-equiv="X-UA-Compatible" content="IE=edge,IE=9,chrome=1"><title>Practical Introduction to Digital Filtering</title><style type="text/css">
* {margin: 0; padding: 0;}
body {text-align: start; line-height: 17.234001159668px; min-height: 0px; white-space: normal; color: rgb(0, 0, 0); font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; font-style: normal; font-size: 14px; font-weight: normal; text-decoration: none; white-space: normal; }
h1, h2 {font-weight: normal;}
.content { padding: 30px; }

.S0 { margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 0px;  }
.S1 { text-align: left; line-height: 26.4000015258789px; min-height: 24px; white-space: pre-wrap; color: rgb(213, 80, 0); font-family: Helvetica, Arial, sans-serif; font-size: 22px; white-space: pre-wrap; margin-left: 4px; margin-top: 3px; margin-bottom: 15px; margin-right: 10px;  }
.S2 { min-height: 0px; margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 0px;  }
.S3 { text-align: left; line-height: 21px; min-height: 17px; white-space: pre-wrap; font-family: Helvetica, Arial, sans-serif; white-space: pre-wrap; margin-left: 4px; margin-top: 2px; margin-bottom: 9px; margin-right: 10px;  }
.S4 { min-height: 0px; color: rgb(0, 95, 206); margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 0px;  }
.S5 { text-align: left; line-height: 20.576000213623px; min-height: 20px; white-space: pre-wrap; color: rgb(60, 60, 60); font-family: Helvetica, Arial, sans-serif; font-size: 16px; font-weight: bold; white-space: pre-wrap; margin-left: 4px; margin-top: 15px; margin-bottom: 9px; margin-right: 10px;  }
.S6 { font-weight: bold; margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 0px;  }
.S7 { margin-left: 3px; margin-top: 10px; margin-bottom: 4px; margin-right: 3px;  }
.S8 { min-height: 18px; white-space: nowrap; white-space: nowrap; margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 0px;  }
.S9 { min-height: 0px; white-space: pre; white-space: pre; margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 0px;  }
.S10 { color: rgb(34, 139, 34); margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 0px;  }
.S11 { color: rgb(160, 32, 240); margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 0px;  }
.S12 { color: rgb(0, 0, 255); margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 0px;  }
.S13 { margin-left: 3px; margin-top: 10px; margin-bottom: 10px; margin-right: 3px;  }
.S14 { text-align: left; line-height: 21px; min-height: 17px; white-space: pre-wrap; font-family: Helvetica, Arial, sans-serif; white-space: pre-wrap; margin-left: 4px; margin-top: 10px; margin-bottom: 9px; margin-right: 10px;  }
.S15 { text-align: left; line-height: 20.576000213623px; min-height: 20px; white-space: pre-wrap; color: rgb(60, 60, 60); font-family: Helvetica, Arial, sans-serif; font-size: 16px; font-weight: bold; white-space: pre-wrap; margin-left: 4px; margin-top: 3px; margin-bottom: 9px; margin-right: 10px;  }
.S16 { margin-left: 3px; margin-top: 4px; margin-bottom: 4px; margin-right: 3px;  }
.S17 { font-family: Helvetica, Arial, sans-serif; margin-left: 0px; margin-top: 10px; margin-bottom: 20px; margin-right: 0px;  }
.S18 { text-align: left; line-height: 21px; white-space: pre-wrap; white-space: pre-wrap; margin-left: 56px; margin-top: 0px; margin-bottom: 0px; margin-right: 0px;  }
.S19 { color: rgb(0, 95, 206); margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 0px;  }
.S20 { font-style: italic; margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 0px;  }

.CodeBlock {margin: 10px 0 10px 0; background-color: #F7F7F7;}
.CodeBlock+.paragraphNode {margin-top: 10px;}
.lineNode {padding-left: 10px; border-left: 1px solid #E9E9E9; border-right: 1px solid #E9E9E9;}
.inlineWrapper:first-child .lineNode,.inlineWrapper.outputs+.inlineWrapper .lineNode {padding-top: 5px; border-top: 1px solid #E9E9E9;}
.inlineWrapper:last-child .lineNode,.inlineWrapper.outputs .lineNode {padding-bottom: 5px; border-bottom: 1px solid #E9E9E9;}
.lineNode .textBox {white-space: pre;}
</style></head><body><div class = "content"><div class = 'SectionBlock containment active'><h1 class = "S1"><span class = "S2"><span class="S0">Practical Introduction to Digital Filtering</span></span></h1><div class = "S3"><span class = "S2"><span class="S0">This example shows how to design, analyze, and apply a digital filter to your data. It will help you answer questions such as: how do I compensate for the delay introduced by a filter?, How do I avoid distorting my signal?, How do I remove unwanted content from my signal?, How do I differentiate my signal?, and How do I integrate my signal?</span></span></div><div class = "S3"><span class = "S2"><span class="S0">Filters can be used to shape the signal spectrum in a desired way or to perform mathematical operations such as differentiation and integration. In what follows you will learn some practical concepts that will ease the use of filters when you need them.</span></span></div><div class = "S3"><span class = "S2"><span class="S0">This example focuses on applications of digital filters rather than on their design. If you want to learn more about how to design digital filters see the</span></span><span class = "S2"><span class="S0"> </span></span><a href = "https://localhost:31515/toolbox/signal/sigdemos/html/FilterDesignIntroductionExample.html"><span class = "S0"><span class="S0">"Practical Introduction to Digital Filter Design"</span></span></a><span class = "S2"><span class="S0"> example.</span></span></div><h2 class = "S5"><span class = "S2"><span class="S0">Compensating for Delay Introduced by Filtering</span></span></h2><div class = "S3"><span class = "S2"><span class="S0">Digital filters introduce delay in your signal. Depending on the filter characteristics, the delay can be constant over all frequencies, or it can vary with frequency. The type of delay determines the actions you have to take to compensate for it. The</span></span><span class = "S2"><span class="S0"> </span></span><span class = "S2"><span class="S6">grpdelay</span></span><span class = "S2"><span class="S0"> function allows you to look at the filter delay as a function of frequency. Looking at the output of this function allows you to identify if the delay of the filter is constant or if it varies with frequency (i.e. if it is frequency-dependent).</span></span></div><div class = "S3"><span class = "S2"><span class="S0">Filter delay that is constant over all frequencies can be easily compensated for by shifting the signal in time. FIR filters usually have constant delay. On the other hand, delay that varies with frequency causes phase distortion and can alter a signal waveform significantly. Compensating for frequency-dependent delay is not as trivial as for the constant delay case. IIR filters introduce frequency-dependent delay.</span></span></div><div class = "S3"><span class = "S2"><span class="S6">Compensating for Constant Filter Delay</span></span></div><div class = "S3"><span class = "S2"><span class="S0">As mentioned before, you can measure the group of delay of the filter to verify that it is a constant function of frequency. You can use the</span></span><span class = "S2"><span class="S0"> </span></span><span class = "S2"><span class="S6">grpdelay</span></span><span class = "S2"><span class="S0"> function to measure the filter delay, D, and compensate for this delay by appending D zeros to the input signal and shifting the output signal in time by D samples.</span></span></div><div class = "S3"><span class = "S2"><span class="S0">Consider a noisy electrocardiogram signal that you want to filter to remove high frequency noise above 75 Hz. You want to apply an FIR lowpass filter and compensate for the filter delay so that the noisy and filtered signals are aligned correctly and can be plotted on top of each other for comparison.</span></span></div><div class = 'CodeBlock contiguous'><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">Fs = 500;                    </span><span class="S10">% sample rate in Hz</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">N = 500;                     </span><span class="S10">% number of signal samples</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">rng </span><span class="S11">default</span><span class="S0">;</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">x = ecg(N)'+0.25*randn(N,1); </span><span class="S10">% noisy waveform</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">t = (0:N-1)/Fs;              </span><span class="S10">% time vector</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0"></span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S10">% Design a 70th order lowpass FIR filter with cutoff frequency of 75 Hz.</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0"></span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">Fnorm = 75/(Fs/2);           </span><span class="S10">% Normalized frequency</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">df = designfilt(</span><span class="S11">'lowpassfir'</span><span class="S0">,</span><span class="S11">'FilterOrder'</span><span class="S0">,70,</span><span class="S11">'CutoffFrequency'</span><span class="S0">,Fnorm);</span></span></div></div></div></div><div class = "S0"></div><div class = 'SectionBlock containment'><div class = "S3"><span class = "S2"><span class="S0">Plot the group delay of the filter to verify that it is constant across all frequencies indicating that the filter is linear phase. Use the group delay to measure the delay of the filter.</span></span></div><div class = 'CodeBlock contiguous'><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">grpdelay(df,2048,Fs)   </span><span class="S10">% plot group delay</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">D = mean(grpdelay(df)) </span><span class="S10">% filter delay in samples</span></span></div></div></div></div><div class = "S0"></div><div class = 'SectionBlock containment'><div class = "S3"><span class = "S2"><span class="S0">Before filtering, append D zeros at the end of the input data vector, x. This ensures that all the useful samples are flushed out of the filter, and that the input signal and the delay-compensated output signal have the same length. Filter the data and compensate for the delay by shifting the output signal by D samples. This last step effectively removes the filter transient.</span></span></div><div class = 'CodeBlock contiguous'><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">y = filter(df,[x; zeros(D,1)]); </span><span class="S10">% Append D zeros to the input data</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">y = y(D+1:end);                  </span><span class="S10">% Shift data to compensate for delay</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0"></span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">figure</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">plot(t,x,t,y,</span><span class="S11">'r'</span><span class="S0">,</span><span class="S11">'linewidth'</span><span class="S0">,1.5);</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">title(</span><span class="S11">'Filtered Waveforms'</span><span class="S0">);</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">xlabel(</span><span class="S11">'Time (s)'</span><span class="S0">)</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">legend(</span><span class="S11">'Original Noisy Signal'</span><span class="S0">,</span><span class="S11">'Filtered Signal'</span><span class="S0">);</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">grid </span><span class="S11">on</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">axis </span><span class="S11">tight</span></span></div></div></div></div><div class = "S0"></div><div class = 'SectionBlock containment'><div class = "S3"><span class = "S2"><span class="S6">Compensating for Frequency-Dependent Delay</span></span></div><div class = "S3"><span class = "S2"><span class="S0">Frequency-dependent delay causes phase distortion in the signal. Compensating for this type of delay is not as trivial as for the constant delay case. If your application allows off-line processing, you can remove the frequency-dependent delay by implementing zero-phase filtering using the</span></span><span class = "S2"><span class="S0"> </span></span><span class = "S2"><span class="S6">filtfilt</span></span><span class = "S2"><span class="S0"> function.</span></span><span class = "S2"><span class="S0"> </span></span><span class = "S2"><span class="S6">filtfilt</span></span><span class = "S2"><span class="S0"> performs zero-phase filtering by processing the input data in both the forward and reverse directions. The main effect is that you obtain zero-phase distortion, i.e., you filter data with an equivalent filter that has a constant delay of 0 samples. Other effects are that you get a filter transfer function which equals the squared magnitude of the original filter transfer function, and a filter order that is double the order of the original filter.</span></span></div><div class = "S3"><span class = "S2"><span class="S0">Consider the ECG signal defined in the previous section. Filter this signal with and without delay compensation.</span></span></div><div class = 'CodeBlock contiguous'><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S10">% Design a 7th order lowpass IIR elliptic filter with cutoff frequency</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S10">% of 75 Hz.</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0"></span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">Fnorm = 75/(Fs/2); </span><span class="S10">% Normalized frequency</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">df = designfilt(</span><span class="S11">'lowpassiir'</span><span class="S0">,</span><span class="S12">...</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">               </span><span class="S11">'PassbandFrequency'</span><span class="S0">,Fnorm,</span><span class="S12">...</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">               </span><span class="S11">'FilterOrder'</span><span class="S0">,7,</span><span class="S12">...</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">               </span><span class="S11">'PassbandRipple'</span><span class="S0">,1,</span><span class="S12">...</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">               </span><span class="S11">'StopbandAttenuation'</span><span class="S0">,60);</span></span></div></div></div></div><div class = "S0"></div><div class = 'SectionBlock containment'><div class = "S3"><span class = "S2"><span class="S0">Plot the group delay of the filter and notice that it varies with frequency indicating that the filter delay is frequency-dependent.</span></span></div><div class = 'CodeBlock contiguous'><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">grpdelay(df,2048,</span><span class="S11">'half'</span><span class="S0">,Fs)</span></span></div></div></div></div><div class = "S0"></div><div class = 'SectionBlock containment'><div class = "S3"><span class = "S2"><span class="S0">Filter the data and look at the effects of each filter implementation on the time signal.</span></span></div><div class = 'CodeBlock contiguous'><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">y1 = filter(df,x);    </span><span class="S10">% non-linear phase filter - no delay compensation</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">y2 = filtfilt(df,x);  </span><span class="S10">% zero-phase implementation - delay compensation</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0"></span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">figure</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">plot(t,x);</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">hold </span><span class="S11">on</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">plot(t,y1,</span><span class="S11">'r'</span><span class="S0">,</span><span class="S11">'linewidth'</span><span class="S0">,1.5);</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">plot(t,y2,</span><span class="S11">'g'</span><span class="S0">,</span><span class="S11">'linewidth'</span><span class="S0">,1.5);</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">title(</span><span class="S11">'Filtered Waveforms'</span><span class="S0">);</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">xlabel(</span><span class="S11">'Time (s)'</span><span class="S0">)</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">legend(</span><span class="S11">'Original Signal'</span><span class="S0">,</span><span class="S11">'Non-linear phase IIR output'</span><span class="S0">,</span><span class="S12">...</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">  </span><span class="S11">'Zero-phase IIR output'</span><span class="S0">);</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">ax = axis;</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">axis([0.25 0.55 ax(3:4)])</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">grid </span><span class="S11">on</span></span></div></div></div><div class = "S14"><span class = "S2"><span class="S0">Notice how zero-phase filtering effectively removes the filter delay.</span></span></div><div class = "S3"><span class = "S2"><span class="S0">Zero-phase filtering is a great tool if your application allows for the non-causal forward/backward filtering operations, and for the change of the filter response to the square of the original response.</span></span></div><div class = "S3"><span class = "S2"><span class="S0">Filters that introduce constant delay are linear phase filters. Filters that introduce frequency-dependent delay are non-linear phase filters.</span></span></div></div><div class = "S0"></div><div class = 'SectionBlock containment'><h2 class = "S15"><span class = "S2"><span class="S0">Removing Unwanted Spectral Content from a Signal</span></span></h2><div class = "S3"><span class = "S2"><span class="S0">Filters are commonly used to remove unwanted spectral content from a signal. You can choose from a variety of filters to do this. You choose a lowpass filter when you want to remove high frequency content, or a highpass filter when you want to remove low frequency content. You can also choose a bandpass filter to remove low and high frequency content while leaving an intermediate band of frequencies intact. You choose a bandstop filter when you want to remove frequencies over a given band.</span></span></div><div class = "S3"><span class = "S2"><span class="S0">Consider an audio signal that has a power-line hum and white noise. The power-line hum is caused by a 60 Hz tone. White noise is a signal that exists across all the audio bandwidth. </span></span></div><div class = "S3"><span class = "S2"><span class="S0">Load the audio signal.</span></span></div><div class = 'CodeBlock contiguous'><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">Fs = 44100; </span><span class="S10">% Sample rate</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">y = audioread(</span><span class="S11">'noisymusic.wav'</span><span class="S0">);</span></span></div></div></div></div><div class = "S0"></div><div class = 'SectionBlock containment'><div class = "S3"><span class = "S2"><span class="S0">Plot the power spectrum of the signal. The red triangular marker shows the strong 60 Hz tone interfering with the audio signal. </span></span></div><div class = 'CodeBlock contiguous'><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">[P,F] = pwelch(y,ones(8192,1),8192/2,8192,Fs,</span><span class="S11">'power'</span><span class="S0">);</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">helperFilterIntroductionPlot1(F,P,[60 60],[-9.365 -9.365],</span><span class="S12">...</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">  {</span><span class="S11">'Original signal power spectrum'</span><span class="S0">, </span><span class="S11">'60 Hz Tone'</span><span class="S0">})</span></span></div></div></div></div><div class = "S0"></div><div class = 'SectionBlock containment'><div class = "S3"><span class = "S2"><span class="S0">You can first remove as much white noise spectral content as possible using a lowpass filter. The passband of the filter should be set to a value that offers a good trade-off between noise reduction and audio degradation due to loss of high frequency content. Applying the lowpass filter before removing the 60 Hz hum is very convenient since you will be able to downsample the band-limited signal. The lower rate signal will allow you to design a sharper and narrower 60 Hz bandstop filter with a smaller filter order.</span></span></div><div class = "S3"><span class = "S2"><span class="S0">Design a lowpass filter with passband frequency of 1 kHz, and stopband frequency of 1.4 kHz. Choose a minimum order design.</span></span></div><div class = 'CodeBlock contiguous'><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">Fp = 1e3;    </span><span class="S10">% Passband frequency in Hz</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">Fst = 1.4e3; </span><span class="S10">% Stopband frequency in Hz</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">Ap = 1;      </span><span class="S10">% Passband ripple in dB</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">Ast = 95;    </span><span class="S10">% Stopband attenuation in dB</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0"></span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S10">% Design the filter </span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">df = designfilt(</span><span class="S11">'lowpassfir'</span><span class="S0">,</span><span class="S11">'PassbandFrequency'</span><span class="S0">,Fp,</span><span class="S12">...</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">                </span><span class="S11">'StopbandFrequency'</span><span class="S0">,Fst,</span><span class="S11">'PassbandRipple'</span><span class="S0">,Ap,</span><span class="S12">...</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">                </span><span class="S11">'StopbandAttenuation'</span><span class="S0">,Ast,</span><span class="S11">'SampleRate'</span><span class="S0">,Fs);</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0"></span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S10">% Analyze the filter response</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">hfvt = fvtool(df,</span><span class="S11">'Fs'</span><span class="S0">,Fs,</span><span class="S11">'FrequencyScale'</span><span class="S0">,</span><span class="S11">'log'</span><span class="S0">,</span><span class="S12">...</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">  </span><span class="S11">'FrequencyRange'</span><span class="S0">,</span><span class="S11">'Specify freq. vector'</span><span class="S0">,</span><span class="S11">'FrequencyVector'</span><span class="S0">,F);</span></span></div></div></div></div><div class = "S0"></div><div class = 'SectionBlock containment'><div class = 'CodeBlock contiguous'><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S10">% Filter the data and compensate for delay</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">D = mean(grpdelay(df)); </span><span class="S10">% filter delay</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">ylp = filter(df,[y; zeros(D,1)]);</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">ylp = ylp(D+1:end);</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0"></span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">close(hfvt)</span></span></div></div></div></div><div class = "S0"></div><div class = 'SectionBlock containment'><div class = "S3"><span class = "S2"><span class="S0">Look at the spectrum of the lowpass filtered signal. Note how the frequency content above 1400 Hz has been removed. </span></span></div><div class = 'CodeBlock contiguous'><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">[Plp,Flp] = pwelch(ylp,ones(8192,1),8192/2,8192,Fs,</span><span class="S11">'power'</span><span class="S0">);</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">helperFilterIntroductionPlot1(F,P,Flp,Plp,</span><span class="S12">...</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">  {</span><span class="S11">'Original signal'</span><span class="S0">,</span><span class="S11">'Lowpass filtered signal'</span><span class="S0">})</span></span></div></div></div></div><div class = "S0"></div><div class = 'SectionBlock containment'><div class = "S3"><span class = "S2"><span class="S0">From the power spectrum plot above, you can see that the maximum non-negligible frequency content of the lowpass filtered signal is at 1400 Hz. By the sampling theorem, a sample frequency of 2*1400 = 2800 Hz would suffice to represent the signal correctly, you however, are using a sample rate of 44100 Hz which is a waste since you will need to process more samples than those necessary. You can downsample the signal to reduce the sample rate and reduce the computational load by reducing the number of samples that you need to process. A lower sample rate will also allow you to design a sharper and narrower bandstop filter, needed to remove the 60 Hz noise, with a smaller filter order.</span></span></div><div class = "S3"><span class = "S2"><span class="S0">Downsample the lowpass filtered signal by a factor of 10 to obtain a sample rate of Fs/10 = 4.41 kHz. Plot the spectrum of the signal before and after downsampling.</span></span></div><div class = 'CodeBlock contiguous'><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">Fs = Fs/10;</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">yds = downsample(ylp,10);</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0"></span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">[Pds,Fds] = pwelch(yds,ones(8192,1),8192/2,8192,Fs,</span><span class="S11">'power'</span><span class="S0">);</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">helperFilterIntroductionPlot1(F,P,Fds,Pds,</span><span class="S12">...</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">  {</span><span class="S11">'Signal sampled at 44100 Hz'</span><span class="S0">, </span><span class="S11">'Downsampled signal, Fs = 4410 Hz'</span><span class="S0">})</span></span></div></div></div></div><div class = "S0"></div><div class = 'SectionBlock containment'><div class = "S3"><span class = "S2"><span class="S0">Now remove the 60 Hz tone using an IIR bandstop filter. Let the stopband have a width of 4 Hz centered at 60 Hz. We choose an IIR filter to achieve a sharp frequency notch, small passband ripple, and a relatively low order. Process the data using</span></span><span class = "S2"><span class="S0"> </span></span><span class = "S2"><span class="S6">filtfilt</span></span><span class = "S2"><span class="S0"> to avoid phase distortion.</span></span></div><div class = 'CodeBlock contiguous'><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S10">% Design the filter</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">df = designfilt(</span><span class="S11">'bandstopiir'</span><span class="S0">,</span><span class="S11">'PassbandFrequency1'</span><span class="S0">,55,</span><span class="S12">...</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">               </span><span class="S11">'StopbandFrequency1'</span><span class="S0">,58,</span><span class="S11">'StopbandFrequency2'</span><span class="S0">,62,</span><span class="S12">...</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">               </span><span class="S11">'PassbandFrequency2'</span><span class="S0">,65,</span><span class="S11">'PassbandRipple1'</span><span class="S0">,1,</span><span class="S12">...</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">               </span><span class="S11">'StopbandAttenuation'</span><span class="S0">,60,</span><span class="S11">'PassbandRipple2'</span><span class="S0">,1,</span><span class="S12">...</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">               </span><span class="S11">'SampleRate'</span><span class="S0">,Fs,</span><span class="S11">'DesignMethod'</span><span class="S0">,</span><span class="S11">'ellip'</span><span class="S0">);                          </span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0"></span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S10">% Analyze the magnitude response</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">hfvt = fvtool(df,</span><span class="S11">'Fs'</span><span class="S0">,Fs,</span><span class="S11">'FrequencyScale'</span><span class="S0">,</span><span class="S11">'log'</span><span class="S0">,</span><span class="S12">...</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">  </span><span class="S11">'FrequencyRange'</span><span class="S0">,</span><span class="S11">'Specify freq. vector'</span><span class="S0">,</span><span class="S11">'FrequencyVector'</span><span class="S0">,Fds(Fds&gt;F(2)));</span></span></div></div></div></div><div class = "S0"></div><div class = 'SectionBlock containment'><div class = "S3"><span class = "S2"><span class="S0">Perform zero-phase filtering to avoid distortion.</span></span></div><div class = 'CodeBlock contiguous'><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">ybs = filtfilt(df,yds);</span></span></div></div></div></div><div class = "S0"></div><div class = 'SectionBlock containment'><div class = "S3"><span class = "S2"><span class="S0">Finally, upsample the signal to bring it back to the original audio sample rate of 44.1 kHz which is compatible with audio soundcards.</span></span></div><div class = 'CodeBlock contiguous'><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">yf = interp(ybs,10);</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">Fs = Fs*10;</span></span></div></div></div></div><div class = "S0"></div><div class = 'SectionBlock containment'><div class = "S3"><span class = "S2"><span class="S0">Take a final look at the spectrum of the original and processed signals. Notice how the high frequency noise floor and the 60 Hz tone have been attenuated by the filters.</span></span></div><div class = 'CodeBlock contiguous'><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">[Pfinal,Ffinal] = pwelch(yf,ones(8192,1),8192/2,8192,Fs,</span><span class="S11">'power'</span><span class="S0">);</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">close(hfvt)</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">helperFilterIntroductionPlot1(F,P,Ffinal,Pfinal,</span><span class="S12">...</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">  {</span><span class="S11">'Original signal'</span><span class="S0">,</span><span class="S11">'Final filtered signal'</span><span class="S0">})</span></span></div></div></div></div><div class = "S0"></div><div class = 'SectionBlock containment'><div class = "S3"><span class = "S2"><span class="S0">Listen to the signal before and after processing. As mentioned above, the end result is that you have effectively attenuated the 60 Hz hum and the high frequency noise on the audio file.</span></span></div><div class = 'CodeBlock contiguous'><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S10">% Play the original signal </span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">hplayer = audioplayer(y, Fs);</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">play(hplayer);</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0"></span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S10">% Play the noise-reduced signal</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">hplayer = audioplayer(yf, Fs);</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">play(hplayer);</span></span></div></div></div></div><div class = "S0"></div><div class = 'SectionBlock containment'><h2 class = "S15"><span class = "S2"><span class="S0">Differentiating a Signal</span></span></h2><div class = "S3"><span class = "S2"><span class="S0">The MATLAB</span></span><span class = "S2"><span class="S0"> </span></span><span class = "S2"><span class="S6">diff</span></span><span class = "S2"><span class="S0"> function differentiates a signal with the drawback that you can potentially increase the noise levels at the output. A better option is to use a differentiator filter that acts as a differentiator in the band of interest, and as an attenuator at all other frequencies, effectively removing high frequency noise.</span></span></div><div class = "S3"><span class = "S2"><span class="S0">As an example, analyze the speed of displacement of a building floor during an earthquake. Displacement or drift measurements were recorded on the first floor of a three story test structure under earthquake conditions and saved in the quakedrift.mat file. The length of the data vector is 10e3, the sample rate is 1 kHz, and the units of the measurements are cm. </span></span></div><div class = "S3"><span class = "S2"><span class="S0">Differentiate the displacement data to obtain estimates of the speed and acceleration of the building floor during the earthquake. Compare the results using diff and an FIR differentiator filter.</span></span></div><div class = 'CodeBlock contiguous'><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">load </span><span class="S11">quakedrift.mat </span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0"></span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">Fs  = 1000;                 </span><span class="S10">% sample rate</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">dt = 1/Fs;                  </span><span class="S10">% time differential</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">t = (0:length(drift)-1)*dt; </span><span class="S10">% time vector</span></span></div></div></div></div><div class = "S0"></div><div class = 'SectionBlock containment'><div class = "S3"><span class = "S2"><span class="S0">Design a 50th order differentiator filter with a passband frequency of 100 Hz which is the bandwidth over which most of the signal energy is found. Set the stopband frequency of the filter to 120 Hz. </span></span></div><div class = 'CodeBlock contiguous'><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">df = designfilt(</span><span class="S11">'differentiatorfir'</span><span class="S0">,</span><span class="S11">'FilterOrder'</span><span class="S0">,50,</span><span class="S12">...</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">                </span><span class="S11">'PassbandFrequency'</span><span class="S0">,100,</span><span class="S11">'StopbandFrequency'</span><span class="S0">,120,</span><span class="S12">...</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">                </span><span class="S11">'SampleRate'</span><span class="S0">,Fs);</span></span></div></div></div></div><div class = "S0"></div><div class = 'SectionBlock containment'><div class = "S3"><span class = "S2"><span class="S0">The</span></span><span class = "S2"><span class="S0"> </span></span><span class = "S2"><span class="S6">diff</span></span><span class = "S2"><span class="S0"> function can be seen as a first order FIR filter with response</span></span><span class = "S2"><span class="S0"> </span></span><span style="vertical-align:-5px"><img src="data:image/png;base64,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" width="104" height="18" /></span><span class = "S2"><span class="S0">. Use FVTool to compare the magnitude response of the 50th order differentiator FIR filter and the response of the</span></span><span class = "S2"><span class="S0"> </span></span><span class = "S2"><span class="S6">diff</span></span><span class = "S2"><span class="S0"> function. Clearly, both responses are equivalent in the passband region (from 0 to 100 Hz). However, in the stopband region, the 50th order filter attenuates components while the diff response amplifies components. This effectively increases the levels of high frequency noise.</span></span></div><div class = 'CodeBlock contiguous'><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">hfvt = fvtool(df,[1 -1],1,</span><span class="S11">'MagnitudeDisplay'</span><span class="S0">,</span><span class="S11">'zero-phase'</span><span class="S0">,</span><span class="S11">'Fs'</span><span class="S0">,Fs);</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">legend(hfvt,</span><span class="S11">'50th order FIR differentiator'</span><span class="S0">,</span><span class="S11">'Response of diff function'</span><span class="S0">);</span></span></div></div></div></div><div class = "S0"></div><div class = 'SectionBlock containment'><div class = "S3"><span class = "S2"><span class="S0">Differentiate using the</span></span><span class = "S2"><span class="S0"> </span></span><span class = "S2"><span class="S6">diff</span></span><span class = "S2"><span class="S0"> function. Add zeros to compensate for the missing samples due to the diff operation.</span></span></div><div class = 'CodeBlock contiguous'><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">v1 = diff(drift)/dt;</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">a1 = diff(v1)/dt;</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0"></span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">v1 = [0; v1];</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">a1 = [0; 0; a1];</span></span></div></div></div></div><div class = "S0"></div><div class = 'SectionBlock containment'><div class = "S3"><span class = "S2"><span class="S0">Differentiate using the 50th order FIR filter and compensate for delay.</span></span></div><div class = 'CodeBlock contiguous'><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">D = mean(grpdelay(df)); </span><span class="S10">% filter delay</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">v2 = filter(df,[drift; zeros(D,1)]);</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">v2 = v2(D+1:end);</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">a2 = filter(df,[v2; zeros(D,1)]);</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">a2 = a2(D+1:end);</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">v2 = v2/dt;</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">a2 = a2/dt^2;</span></span></div></div></div></div><div class = "S0"></div><div class = 'SectionBlock containment'><div class = "S3"><span class = "S2"><span class="S0">Plot a few data points of the floor displacement. Plot also a few data points of the speed and acceleration as computed with diff and with the 50th order FIR filter. Notice how the noise has been slightly amplified in the speed estimates and largely amplified in the acceleration estimates obtained with</span></span><span class = "S2"><span class="S0"> </span></span><span class = "S2"><span class="S6">diff</span></span><span class = "S2"><span class="S0">.</span></span></div><div class = 'CodeBlock contiguous'><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">helperFilterIntroductionPlot2(t,drift,v1,v2,a1,a2)</span></span></div></div></div></div><div class = "S0"></div><div class = 'SectionBlock containment'><h2 class = "S15"><span class = "S2"><span class="S0">Integrating a Signal</span></span></h2><div class = "S3"><span class = "S2"><span class="S0">A leaky integrator filter is an all-pole filter with transfer function</span></span><span class = "S2"><span class="S0"> </span></span><span style="vertical-align:-5px"><img src="data:image/png;base64,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" width="136" height="18" /></span><span class = "S2"><span class="S0"> where</span></span><span class = "S2"><span class="S0"> </span></span><span style="font-family: STIXGeneral, STIXGeneral-webfont, serif; font-style: italic; font-weight: normal;">c</span><span class = "S2"><span class="S0"> is a constant that must be smaller than 1 to ensure stability of the filter. It is no surprise that as</span></span><span class = "S2"><span class="S0"> </span></span><span style="font-family: STIXGeneral, STIXGeneral-webfont, serif; font-style: italic; font-weight: normal;">c</span><span class = "S2"><span class="S0"> approaches one, the leaky integrator approaches the inverse of the</span></span><span class = "S2"><span class="S0"> </span></span><span class = "S2"><span class="S6">diff</span></span><span class = "S2"><span class="S0"> transfer function. Apply the leaky integrator to the acceleration and speed estimates obtained in the previous section to get back the speed and the drift respectively. Use the estimates obtained with the</span></span><span class = "S2"><span class="S0"> </span></span><span class = "S2"><span class="S6">diff</span></span><span class = "S2"><span class="S0"> function since they are noisier.</span></span></div><div class = "S3"><span class = "S2"><span class="S0">Use a leaky integrator with</span></span><span class = "S2"><span class="S0"> </span></span><span style="vertical-align:-5px"><img src="data:image/png;base64,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" width="63" height="17" /></span><span class = "S2"><span class="S0">. Plot the magnitude response of the leaky integrator filter. Notice that the filter acts as a lowpass filter effectively eliminating high frequency noise.</span></span></div><div class = 'CodeBlock contiguous'><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">close(hfvt)</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">fvtool(1,[1 -.999],</span><span class="S11">'Fs'</span><span class="S0">,Fs)</span></span></div></div></div></div><div class = "S0"></div><div class = 'SectionBlock containment'><div class = "S3"><span class = "S2"><span class="S0">Filter the velocity and acceleration with the leaky integrator.</span></span></div><div class = 'CodeBlock contiguous'><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">v_original = v1;</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">a_original = a1;</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0"></span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">d_leakyint = filter(1,[1 -0.999],v_original);</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">v_leakyint = filter(1,[1 -0.999],a_original);</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0"></span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S10">% Multiply by time differential</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">d_leakyint = d_leakyint * dt;</span></span></div></div><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">v_leakyint = v_leakyint * dt;</span></span></div></div></div></div><div class = "S0"></div><div class = 'SectionBlock containment'><div class = "S3"><span class = "S2"><span class="S0">Plot the displacement and speed estimates and compare to the original signals v1 and a1. </span></span></div><div class = 'CodeBlock contiguous'><div class = 'inlineWrapper'><div class = "S8 lineNode"><span class = "S9"><span class="S0">helperFilterIntroductionPlot3(t,drift,d_leakyint,v_original,v_leakyint)</span></span></div></div></div><div class = "S14"><span class = "S2"><span class="S0">You can also integrate a signal using the</span></span><span class = "S2"><span class="S0"> </span></span><span class = "S2"><span class="S6">cumsum</span></span><span class = "S2"><span class="S0"> and</span></span><span class = "S2"><span class="S0"> </span></span><span class = "S2"><span class="S6">cumtrapz</span></span><span class = "S2"><span class="S0"> functions. Results will be similar to those obtained with the leaky integrator.</span></span></div></div><div class = "S0"></div><div class = 'SectionBlock containment'><h2 class = "S15"><span class = "S2"><span class="S0">Conclusions</span></span></h2><div class = "S3"><span class = "S2"><span class="S0">In this example you learned about linear and nonlinear phase filters and you learned how to compensate for the phase delay introduced by each filter type. You also learned how to apply filters to remove unwanted frequency components from a signal, and how to downsample a signal after limiting its bandwidth with a lowpass filter. Finally, you learned how to differentiate and integrate a signal using digital filter designs. Throughout the example you also learned how to use analysis tools to look at the response and group delay of your filters.</span></span></div><h2 class = "S5"><span class = "S2"><span class="S0">Further Reading</span></span></h2><div class = "S3"><span class = "S2"><span class="S0">For more information on filter applications see the Signal Processing Toolbox. For more information on how to design digital filters see the</span></span><span class = "S2"><span class="S0"> </span></span><a href = "https://localhost:31515/toolbox/signal/sigdemos/html/FilterDesignIntroductionExample.html"><span class = "S0"><span class="S0">"Practical Introduction to Digital Filter Design"</span></span></a><span class = "S2"><span class="S0"> example.</span></span></div><div class = "S3"><span class = "S2"><span class="S0">References: J.G. Proakis and D. G. Manolakis, "Digital Signal Processing. Principles, Algorithms, and Applications", Prentice-Hall, 1996.</span></span></div><div class = "S3"><span class = "S2"><span class="S0">S. J. Orfanidis, "Introduction To Signal Processing", Prentice-Hall, 1996.</span></span></div><h2 class = "S5"><span class = "S2"><span class="S0">Appendix</span></span></h2><div class = "S3"><span class = "S2"><span class="S0">The following helper functions are used in this example.</span></span></div><ul class = "S17"><li class = "S18"><a href = "matlab:edit('helperFilterIntroductionPlot1.m')"><span class = "S0"><span class="S0">helperFilterIntroductionPlot1.m</span></span></a></li><li class = "S18"><a href = "matlab:edit('helperFilterIntroductionPlot2.m')"><span class = "S0"><span class="S0">helperFilterIntroductionPlot2.m</span></span></a></li><li class = "S18"><a href = "matlab:edit('helperFilterIntroductionPlot3.m')"><span class = "S0"><span class="S0">helperFilterIntroductionPlot3.m</span></span></a></li></ul><div class = "S3"><span class = "S2"><span class="S20">Copyright 2012-2013 The MathWorks, Inc.</span></span></div></div></div><br><!-- <br>##### SOURCE BEGIN #####<br>%% Practical Introduction to Digital Filtering<br>% This example shows how to design, analyze, and apply a digital filter to your <br>% data. It will help you answer questions such as: how do I compensate for the <br>% delay introduced by a filter?, How do I avoid distorting my signal?, How do <br>% I remove unwanted content from my signal?, How do I differentiate my signal?, <br>% and How do I integrate my signal?<br>% <br>% Filters can be used to shape the signal spectrum in a desired way or to <br>% perform mathematical operations such as differentiation and integration. In <br>% what follows you will learn some practical concepts that will ease the use of <br>% filters when you need them.<br>% <br>% This example focuses on applications of digital filters rather than on <br>% their design. If you want to learn more about how to design digital filters <br>% see the <../../../signal/sigdemos/html/FilterDesignIntroductionExample.html <br>% "Practical Introduction to Digital Filter Design"> example.<br>%% Compensating for Delay Introduced by Filtering<br>% Digital filters introduce delay in your signal. Depending on the filter characteristics, <br>% the delay can be constant over all frequencies, or it can vary with frequency. <br>% The type of delay determines the actions you have to take to compensate for <br>% it. The *grpdelay* function allows you to look at the filter delay as a function <br>% of frequency. Looking at the output of this function allows you to identify <br>% if the delay of the filter is constant or if it varies with frequency (i.e. <br>% if it is frequency-dependent).<br>% <br>% Filter delay that is constant over all frequencies can be easily compensated <br>% for by shifting the signal in time. FIR filters usually have constant delay. <br>% On the other hand, delay that varies with frequency causes phase distortion <br>% and can alter a signal waveform significantly. Compensating for frequency-dependent <br>% delay is not as trivial as for the constant delay case. IIR filters introduce <br>% frequency-dependent delay.<br>% <br>% *Compensating for Constant Filter Delay*<br>% <br>% As mentioned before, you can measure the group of delay of the filter to <br>% verify that it is a constant function of frequency. You can use the *grpdelay* <br>% function to measure the filter delay, D, and compensate for this delay by appending <br>% D zeros to the input signal and shifting the output signal in time by D samples.<br>% <br>% Consider a noisy electrocardiogram signal that you want to filter to remove <br>% high frequency noise above 75 Hz. You want to apply an FIR lowpass filter and <br>% compensate for the filter delay so that the noisy and filtered signals are aligned <br>% correctly and can be plotted on top of each other for comparison.<br><br>Fs = 500;                    % sample rate in Hz<br>N = 500;                     % number of signal samples<br>rng default;<br>x = ecg(N)'+0.25*randn(N,1); % noisy waveform<br>t = (0:N-1)/Fs;              % time vector<br><br>% Design a 70th order lowpass FIR filter with cutoff frequency of 75 Hz.<br><br>Fnorm = 75/(Fs/2);           % Normalized frequency<br>df = designfilt('lowpassfir','FilterOrder',70,'CutoffFrequency',Fnorm);<br>%% <br>% Plot the group delay of the filter to verify that it is constant across <br>% all frequencies indicating that the filter is linear phase. Use the group delay <br>% to measure the delay of the filter.<br>%%<br>grpdelay(df,2048,Fs)   % plot group delay<br>D = mean(grpdelay(df)) % filter delay in samples<br>%% <br>% Before filtering, append D zeros at the end of the input data vector, <br>% x. This ensures that all the useful samples are flushed out of the filter, and <br>% that the input signal and the delay-compensated output signal have the same <br>% length. Filter the data and compensate for the delay by shifting the output <br>% signal by D samples. This last step effectively removes the filter transient.<br>%%<br>y = filter(df,[x; zeros(D,1)]); % Append D zeros to the input data<br>y = y(D+1:end);                  % Shift data to compensate for delay<br><br>figure<br>plot(t,x,t,y,'r','linewidth',1.5);<br>title('Filtered Waveforms');<br>xlabel('Time (s)')<br>legend('Original Noisy Signal','Filtered Signal');<br>grid on<br>axis tight<br>%% <br>% *Compensating for Frequency-Dependent Delay*<br>% <br>% Frequency-dependent delay causes phase distortion in the signal. Compensating <br>% for this type of delay is not as trivial as for the constant delay case. If <br>% your application allows off-line processing, you can remove the frequency-dependent <br>% delay by implementing zero-phase filtering using the *filtfilt* function. *filtfilt* <br>% performs zero-phase filtering by processing the input data in both the forward <br>% and reverse directions. The main effect is that you obtain zero-phase distortion, <br>% i.e., you filter data with an equivalent filter that has a constant delay of <br>% 0 samples. Other effects are that you get a filter transfer function which equals <br>% the squared magnitude of the original filter transfer function, and a filter <br>% order that is double the order of the original filter.<br>% <br>% Consider the ECG signal defined in the previous section. Filter this signal <br>% with and without delay compensation.<br>%%<br>% Design a 7th order lowpass IIR elliptic filter with cutoff frequency<br>% of 75 Hz.<br><br>Fnorm = 75/(Fs/2); % Normalized frequency<br>df = designfilt('lowpassiir',...<br>               'PassbandFrequency',Fnorm,...<br>               'FilterOrder',7,...<br>               'PassbandRipple',1,...<br>               'StopbandAttenuation',60);<br>%% <br>% Plot the group delay of the filter and notice that it varies with frequency <br>% indicating that the filter delay is frequency-dependent.<br>%%<br>grpdelay(df,2048,'half',Fs)<br>%% <br>% Filter the data and look at the effects of each filter implementation <br>% on the time signal.<br>%%<br>y1 = filter(df,x);    % non-linear phase filter - no delay compensation<br>y2 = filtfilt(df,x);  % zero-phase implementation - delay compensation<br><br>figure<br>plot(t,x);<br>hold on<br>plot(t,y1,'r','linewidth',1.5);<br>plot(t,y2,'g','linewidth',1.5);<br>title('Filtered Waveforms');<br>xlabel('Time (s)')<br>legend('Original Signal','Non-linear phase IIR output',...<br>  'Zero-phase IIR output');<br>ax = axis;<br>axis([0.25 0.55 ax(3:4)])<br>grid on<br>%% <br>% Notice how zero-phase filtering effectively removes the filter delay.<br>% <br>% Zero-phase filtering is a great tool if your application allows for the <br>% non-causal forward/backward filtering operations, and for the change of the <br>% filter response to the square of the original response.<br>% <br>% Filters that introduce constant delay are linear phase filters. Filters <br>% that introduce frequency-dependent delay are non-linear phase filters.<br>%% Removing Unwanted Spectral Content from a Signal<br>% Filters are commonly used to remove unwanted spectral content from a signal. <br>% You can choose from a variety of filters to do this. You choose a lowpass filter <br>% when you want to remove high frequency content, or a highpass filter when you <br>% want to remove low frequency content. You can also choose a bandpass filter <br>% to remove low and high frequency content while leaving an intermediate band <br>% of frequencies intact. You choose a bandstop filter when you want to remove <br>% frequencies over a given band.<br>% <br>% Consider an audio signal that has a power-line hum and white noise. The <br>% power-line hum is caused by a 60 Hz tone. White noise is a signal that exists <br>% across all the audio bandwidth. <br>% <br>% Load the audio signal.<br>%%<br>Fs = 44100; % Sample rate<br>y = audioread('noisymusic.wav');<br>%% <br>% Plot the power spectrum of the signal. The red triangular marker shows <br>% the strong 60 Hz tone interfering with the audio signal. <br>%%<br>[P,F] = pwelch(y,ones(8192,1),8192/2,8192,Fs,'power');<br>helperFilterIntroductionPlot1(F,P,[60 60],[-9.365 -9.365],...<br>  {'Original signal power spectrum', '60 Hz Tone'})<br>%% <br>% You can first remove as much white noise spectral content as possible <br>% using a lowpass filter. The passband of the filter should be set to a value <br>% that offers a good trade-off between noise reduction and audio degradation due <br>% to loss of high frequency content. Applying the lowpass filter before removing <br>% the 60 Hz hum is very convenient since you will be able to downsample the band-limited <br>% signal. The lower rate signal will allow you to design a sharper and narrower <br>% 60 Hz bandstop filter with a smaller filter order.<br>% <br>% Design a lowpass filter with passband frequency of 1 kHz, and stopband <br>% frequency of 1.4 kHz. Choose a minimum order design.<br>%%<br>Fp = 1e3;    % Passband frequency in Hz<br>Fst = 1.4e3; % Stopband frequency in Hz<br>Ap = 1;      % Passband ripple in dB<br>Ast = 95;    % Stopband attenuation in dB<br><br>% Design the filter <br>df = designfilt('lowpassfir','PassbandFrequency',Fp,...<br>                'StopbandFrequency',Fst,'PassbandRipple',Ap,...<br>                'StopbandAttenuation',Ast,'SampleRate',Fs);<br><br>% Analyze the filter response<br>hfvt = fvtool(df,'Fs',Fs,'FrequencyScale','log',...<br>  'FrequencyRange','Specify freq. vector','FrequencyVector',F);<br>%%<br>% Filter the data and compensate for delay<br>D = mean(grpdelay(df)); % filter delay<br>ylp = filter(df,[y; zeros(D,1)]);<br>ylp = ylp(D+1:end);<br><br>close(hfvt)<br>%% <br>% Look at the spectrum of the lowpass filtered signal. Note how the frequency <br>% content above 1400 Hz has been removed. <br>%%<br>[Plp,Flp] = pwelch(ylp,ones(8192,1),8192/2,8192,Fs,'power');<br>helperFilterIntroductionPlot1(F,P,Flp,Plp,...<br>  {'Original signal','Lowpass filtered signal'})<br>%% <br>% From the power spectrum plot above, you can see that the maximum non-negligible <br>% frequency content of the lowpass filtered signal is at 1400 Hz. By the sampling <br>% theorem, a sample frequency of 2*1400 = 2800 Hz would suffice to represent the <br>% signal correctly, you however, are using a sample rate of 44100 Hz which is <br>% a waste since you will need to process more samples than those necessary. You <br>% can downsample the signal to reduce the sample rate and reduce the computational <br>% load by reducing the number of samples that you need to process. A lower sample <br>% rate will also allow you to design a sharper and narrower bandstop filter, needed <br>% to remove the 60 Hz noise, with a smaller filter order.<br>% <br>% Downsample the lowpass filtered signal by a factor of 10 to obtain a sample <br>% rate of Fs/10 = 4.41 kHz. Plot the spectrum of the signal before and after downsampling.<br>%%<br>Fs = Fs/10;<br>yds = downsample(ylp,10);<br><br>[Pds,Fds] = pwelch(yds,ones(8192,1),8192/2,8192,Fs,'power');<br>helperFilterIntroductionPlot1(F,P,Fds,Pds,...<br>  {'Signal sampled at 44100 Hz', 'Downsampled signal, Fs = 4410 Hz'})<br>%% <br>% Now remove the 60 Hz tone using an IIR bandstop filter. Let the stopband <br>% have a width of 4 Hz centered at 60 Hz. We choose an IIR filter to achieve a <br>% sharp frequency notch, small passband ripple, and a relatively low order. Process <br>% the data using *filtfilt* to avoid phase distortion.<br>%%<br>% Design the filter<br>df = designfilt('bandstopiir','PassbandFrequency1',55,...<br>               'StopbandFrequency1',58,'StopbandFrequency2',62,...<br>               'PassbandFrequency2',65,'PassbandRipple1',1,...<br>               'StopbandAttenuation',60,'PassbandRipple2',1,...<br>               'SampleRate',Fs,'DesignMethod','ellip');                          <br><br>% Analyze the magnitude response<br>hfvt = fvtool(df,'Fs',Fs,'FrequencyScale','log',...<br>  'FrequencyRange','Specify freq. vector','FrequencyVector',Fds(Fds>F(2)));<br>%% <br>% Perform zero-phase filtering to avoid distortion.<br>%%<br>ybs = filtfilt(df,yds);<br>%% <br>% Finally, upsample the signal to bring it back to the original audio sample <br>% rate of 44.1 kHz which is compatible with audio soundcards.<br>%%<br>yf = interp(ybs,10);<br>Fs = Fs*10;<br>%% <br>% Take a final look at the spectrum of the original and processed signals. <br>% Notice how the high frequency noise floor and the 60 Hz tone have been attenuated <br>% by the filters.<br>%%<br>[Pfinal,Ffinal] = pwelch(yf,ones(8192,1),8192/2,8192,Fs,'power');<br>close(hfvt)<br>helperFilterIntroductionPlot1(F,P,Ffinal,Pfinal,...<br>  {'Original signal','Final filtered signal'})<br>%% <br>% Listen to the signal before and after processing. As mentioned above, <br>% the end result is that you have effectively attenuated the 60 Hz hum and the <br>% high frequency noise on the audio file.<br>%%<br>% Play the original signal <br>hplayer = audioplayer(y, Fs);<br>play(hplayer);<br><br>% Play the noise-reduced signal<br>hplayer = audioplayer(yf, Fs);<br>play(hplayer);<br>%% Differentiating a Signal<br>% The MATLAB *diff* function differentiates a signal with the drawback that <br>% you can potentially increase the noise levels at the output. A better option <br>% is to use a differentiator filter that acts as a differentiator in the band <br>% of interest, and as an attenuator at all other frequencies, effectively removing <br>% high frequency noise.<br>% <br>% As an example, analyze the speed of displacement of a building floor during <br>% an earthquake. Displacement or drift measurements were recorded on the first <br>% floor of a three story test structure under earthquake conditions and saved <br>% in the quakedrift.mat file. The length of the data vector is 10e3, the sample <br>% rate is 1 kHz, and the units of the measurements are cm. <br>% <br>% Differentiate the displacement data to obtain estimates of the speed and <br>% acceleration of the building floor during the earthquake. Compare the results <br>% using diff and an FIR differentiator filter.<br>%%<br>load quakedrift.mat <br><br>Fs  = 1000;                 % sample rate<br>dt = 1/Fs;                  % time differential<br>t = (0:length(drift)-1)*dt; % time vector<br>%% <br>% Design a 50th order differentiator filter with a passband frequency of <br>% 100 Hz which is the bandwidth over which most of the signal energy is found. <br>% Set the stopband frequency of the filter to 120 Hz. <br>%%<br>df = designfilt('differentiatorfir','FilterOrder',50,...<br>                'PassbandFrequency',100,'StopbandFrequency',120,...<br>                'SampleRate',Fs);<br>%% <br>% The *diff* function can be seen as a first order FIR filter with response <br>% $H(Z) = 1 - Z^{-1}$. Use FVTool to compare the magnitude response of the 50th <br>% order differentiator FIR filter and the response of the *diff* function. Clearly, <br>% both responses are equivalent in the passband region (from 0 to 100 Hz). However, <br>% in the stopband region, the 50th order filter attenuates components while the <br>% diff response amplifies components. This effectively increases the levels of <br>% high frequency noise.<br>%%<br>hfvt = fvtool(df,[1 -1],1,'MagnitudeDisplay','zero-phase','Fs',Fs);<br>legend(hfvt,'50th order FIR differentiator','Response of diff function');<br>%% <br>% Differentiate using the *diff* function. Add zeros to compensate for the <br>% missing samples due to the diff operation.<br>%%<br>v1 = diff(drift)/dt;<br>a1 = diff(v1)/dt;<br><br>v1 = [0; v1];<br>a1 = [0; 0; a1];<br>%% <br>% Differentiate using the 50th order FIR filter and compensate for delay.<br>%%<br>D = mean(grpdelay(df)); % filter delay<br>v2 = filter(df,[drift; zeros(D,1)]);<br>v2 = v2(D+1:end);<br>a2 = filter(df,[v2; zeros(D,1)]);<br>a2 = a2(D+1:end);<br>v2 = v2/dt;<br>a2 = a2/dt^2;<br>%% <br>% Plot a few data points of the floor displacement. Plot also a few data <br>% points of the speed and acceleration as computed with diff and with the 50th <br>% order FIR filter. Notice how the noise has been slightly amplified in the speed <br>% estimates and largely amplified in the acceleration estimates obtained with <br>% *diff*.<br>%%<br>helperFilterIntroductionPlot2(t,drift,v1,v2,a1,a2)<br>%% Integrating a Signal<br>% A leaky integrator filter is an all-pole filter with transfer function $H(Z) <br>% = 1/[1-cZ^{-1}]$ where $c$ is a constant that must be smaller than 1 to ensure <br>% stability of the filter. It is no surprise that as $c$ approaches one, the leaky <br>% integrator approaches the inverse of the *diff* transfer function. Apply the <br>% leaky integrator to the acceleration and speed estimates obtained in the previous <br>% section to get back the speed and the drift respectively. Use the estimates <br>% obtained with the *diff* function since they are noisier.<br>% <br>% Use a leaky integrator with $a = 0.999$. Plot the magnitude response of <br>% the leaky integrator filter. Notice that the filter acts as a lowpass filter <br>% effectively eliminating high frequency noise.<br>%%<br>close(hfvt)<br>fvtool(1,[1 -.999],'Fs',Fs)<br>%% <br>% Filter the velocity and acceleration with the leaky integrator.<br>%%<br>v_original = v1;<br>a_original = a1;<br><br>d_leakyint = filter(1,[1 -0.999],v_original);<br>v_leakyint = filter(1,[1 -0.999],a_original);<br><br>% Multiply by time differential<br>d_leakyint = d_leakyint * dt;<br>v_leakyint = v_leakyint * dt;<br>%% <br>% Plot the displacement and speed estimates and compare to the original <br>% signals v1 and a1. <br>%%<br>helperFilterIntroductionPlot3(t,drift,d_leakyint,v_original,v_leakyint)<br>%% <br>% You can also integrate a signal using the *cumsum* and *cumtrapz* functions. <br>% Results will be similar to those obtained with the leaky integrator.<br>%% Conclusions<br>% In this example you learned about linear and nonlinear phase filters and you <br>% learned how to compensate for the phase delay introduced by each filter type. <br>% You also learned how to apply filters to remove unwanted frequency components <br>% from a signal, and how to downsample a signal after limiting its bandwidth with <br>% a lowpass filter. Finally, you learned how to differentiate and integrate a <br>% signal using digital filter designs. Throughout the example you also learned <br>% how to use analysis tools to look at the response and group delay of your filters.<br>%% Further Reading<br>% For more information on filter applications see the Signal Processing Toolbox. <br>% For more information on how to design digital filters see the <../../../signal/sigdemos/html/FilterDesignIntroductionExample.html <br>% "Practical Introduction to Digital Filter Design"> example.<br>% <br>% References: J.G. Proakis and D. G. Manolakis, "Digital Signal Processing. <br>% Principles, Algorithms, and Applications", Prentice-Hall, 1996.<br>% <br>% S. J. Orfanidis, "Introduction To Signal Processing", Prentice-Hall, 1996.<br>%% Appendix<br>% The following helper functions are used in this example.<br>% <br>% * <matlab:edit('helperFilterIntroductionPlot1.m') helperFilterIntroductionPlot1.m><br>% * <matlab:edit('helperFilterIntroductionPlot2.m') helperFilterIntroductionPlot2.m><br>% * <matlab:edit('helperFilterIntroductionPlot3.m') helperFilterIntroductionPlot3.m><br>% <br>% _Copyright 2012-2013 The MathWorks, Inc._<br>##### SOURCE END #####<br>--></body></html>